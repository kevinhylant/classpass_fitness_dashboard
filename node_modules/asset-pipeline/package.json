{
  "name": "asset-pipeline",
  "description": "Runtime assets builder for Express 3",
  "version": "0.3.2",
  "author": {
    "name": "Alex Kocharin",
    "email": "alex@kocharin.ru"
  },
  "dependencies": {
    "send": ">= 0.1.0",
    "async": "*",
    "async-cache": "*",
    "temporary": "*",
    "commander": "*",
    "rimraf": "*"
  },
  "devDependencies": {
    "express": ">= 3",
    "coffee-script": ">= 1.3.3",
    "haml": ">= 0.4.3",
    "jade": "*",
    "ejs": ">= 0.8.2",
    "node-markdown": ">= 0.1.1",
    "less": ">= 1.3.0",
    "stylus": ">= 0.29.0",
    "eco": ">= 1.1.0-rc-3",
    "js-yaml": "*"
  },
  "keywords": [
    "express",
    "assets",
    "build",
    "coffee",
    "jade",
    "stylus",
    "ejs",
    "haml",
    "markdown"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/rlidwka/asset-pipeline.git"
  },
  "main": "index",
  "bin": {
    "asset-pipeline": "./bin/asset-pipeline"
  },
  "engines": {
    "node": ">= 0.6.0"
  },
  "readme": "Assets preprocessor/compiler for Node.js/Express. It supports a lot of popular js/css compilers like `jade`, `coffeescript`, `less`, `stylus`, `ejs`, etc. and allows all these compilers to work together.\n\nThis module is inspired by Asset Pipeline (from Rails world).\n\nMain idea of this framework is applying different filters to input files based on file extension. For example, user requested\t`file.js`. But you don't write js, you write coffeescript with some preprocessor. So, this framework looks for `file.js.coffee.pp`, pipes it to preprocessor and gets `file.js.coffee`. Than compiles it to `file.js` and so on.\n\nSo typical build process looks like this:\n```\n                                              .- module1.coffee\nfile-cLee7vJT.js <-- file.js <-- file.js.ejs {-- module2.coffee                             .- template1.js.jade\n                                              `- templates.coffee <-- templates.coffee.ejs {-- template2.js.jade\n                                                                                            `- template3.js.jade\n                                                 .- module1.less\nfile-USzt9bQs.css <-- file.css <-- file.css.ejs {-- module2.styl         .- image1.png\n                                                 `- backgrounds.css.ejs {-- image2.png\n                                                                         `- image3.png\n```\n\nIt means that you have a whole bunch of different files in your project, and this module can combine them together in any way you want.\n\nModule builds a file when user requests it first time, and then tracks all its dependencies to see if anything is changed. So first request is usually slow, but other requests should be as fast as requests to static files.\n\n# Usage examples\n\nSee tests application, I hope it can give some ideas how it can be used.\n\n# Command-line interface\n\n```bash\n$ echo 'test = -> console.log(<%=1+1%>)' > test.js.coffee.ejs\n\n$ asset-pipeline test.js.coffee.ejs\ntest = -> console.log(<%=1+1%>)\n\n$ asset-pipeline test.js.coffee\ntest = -> console.log(2)\n\n$ asset-pipeline test.js\n(function() {\n  var test;\n\n  test = function() {\n    return console.log(2);\n  };\n\n}).call(this);\n```\n\n# Syntax (for Express framework):\n\n```javascript\n// here's standard Express server declaration\nvar express = require('express')\napp = express.createServer();\napp.listen(80);\n\n// configuring assets pipeline (full definition of config options see below)\napp.use(require('asset-pipeline')({\n\t// reference to a server itself (used in views rendering)\n\tserver: app,\n\t// directory with your stylesheets or client-side scripts\n\tassets: './assets',\n\t// directory for cache\n\tcache: './cache',\n}))\n```\n\n# Config options\n\n- `assets` (default: `\"./assets\"`) - path to your assets (directory where this module does search all files and dependencies)\n- `cache` (default: `\"./cache\"`) - path to a cache (you should create an empty directory where all compiled assets will be prepared and served)\n- `extensions` (default: `[\".js\", \".css\"]`) - if user have requested file without md5 in it, module will serve to user only files with these extensions (see below)\n- `files` (default: []) - a list of additional files you want to serve (see below)\n- `min_check_time` (default: 1000) - time in milliseconds, module won't check any file for updates faster than specified here (set a small value for development but large on production)\n- `debug` - print to stdout some additional debug info\n\n# Supported plugins\n\n## Embedded javascript (EJS)\n\nIt is a template engine. I put it first because I use it almost everywhere as a clue between files.\n\nThis plugin can transform `FILE.ejs` to `FILE`. You need to have `ejs` module installed.\n\nFor example, if I want to have a coffeescript file `file.coffee` with compiled jade template located in `template.jade` in it, I will write a file `file.coffee.ejs` with something like that:\n\n```coffeescript\n# build a template function\n`var template = <%-asset_include('template.js') %>;`\n\n# use template function somehow\n$('.data').first().after(template(users: args))\n```\n\n## Coffeescript\n\nCoffeescript language compiler. It's used often to compile client-side javascript out of coffeescript sources.\n\nThis plugin can transform `FILE.coffee` to `FILE` or `FILE.js`. You need to have `coffee-script` or `iced-coffee-script` installed.\n\n## Iced Coffeescript\n\nIced Coffeescript compiler.\n\nThis plugin can transform `FILE.iced` to `FILE` or `FILE.js`. You need to have `iced-coffee-script` module installed.\n\n## Embedded coffeescript (ECO)\n\nEmbedded coffeescript. Honestly, I didn't find this plugin useful.\n\nThis plugin will transform `FILE.eco` to `FILE`. You need to have `eco` module installed.\n\n## Less CSS\n\nCSS preprocessor.\n\nThis plugin will transform `FILE.less` to `FILE` or `FILE.css`. You need to have `less` module installed.\n\n## Stylus\n\nCSS preprocessor.\n\nThis plugin will transform `FILE.styl` to `FILE` or `FILE.css`. You need to have `stylus` module installed.\n\n## Jade compiler\n\nJade compiler. This plugin is used to build a compiled template (a javascript function) out of jade template.\n\nThis plugin can transform `FILE.jade` to `FILE` or `FILE.js`. You need to have `jade` module installed.\n\n## Jade renderer\n\nJade compiler. This plugin is used to render a html page out of jade template.\n\nThis plugin can transform `FILE.jade` to `FILE` or `FILE.html`. You need to have `jade` module installed.\n\n## Haml\n\nHAML language. I use Jade instead of it, but maybe it'll be useful for someone.\n\nThis plugin will transform `FILE.haml` to `FILE` or `FILE.html`. You need to have `haml` module installed.\n\n## Markdown\n\nMarkdown language. Can be used to build up a HTML page.\n\nThis plugin will transform `FILE.md` to `FILE` or `FILE.html`. You need to have `node-markdown` module installed. I know there is a lot of markdown modules, so ask me if you want to use another one.\n\n# Writing custom plugin\n\nIf you have some compiler you want to use, and it is not (yet?) supported by assets-pipeline, you can just write your own module and copy it to plugins directory.\n\nYour module should export object simular to that (you can look inside existing plugins):\n\n```javascript\nmodule.exports = {\n  // file extension (or array of these extensions) of files \n  // that will be processed by your plugin, mandatory\n  source: 'coffee',\n\n  // file extension (or array of these extensions) of target files, optional\n  target: 'js',\n\n  // your compiler, arguments: source code, some options \n  // (options.filename is quite useful) and a callback(err, compiled_code)\n  compile: function(code, options, callback) {\n    callback(null, require('coffee-script').compile(code));\n  }\n};\n```\n\nIf your compiler does not support including other files, your plugin will be nice and simple. If it does and you want to track all dependencies, just write an issue and ask for help (because of some really dark magic starting here).\n\n# Philosophy\n\nThis library writes output files to a cache and calls connect.static to serve them.\nReasons:\n\n- in development enviroment: it's more verbose and logical. Pipeline is for compiling, Express.static for serving. You can always see what is in the cache and so on.\n- in production enviroment: assets-pipeline just exports a few template functions. So, in production there will be no performance impact.\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/rlidwka/asset-pipeline/issues"
  },
  "_id": "asset-pipeline@0.3.2",
  "dist": {
    "shasum": "28af32b452b9fd28975133809cfd411fc8b21879",
    "tarball": "http://registry.npmjs.org/asset-pipeline/-/asset-pipeline-0.3.2.tgz"
  },
  "_from": "asset-pipeline@*",
  "_npmVersion": "1.3.1",
  "_npmUser": {
    "name": "rlidwka",
    "email": "alex@kocharin.ru"
  },
  "maintainers": [
    {
      "name": "rlidwka",
      "email": "alex@kocharin.ru"
    }
  ],
  "directories": {},
  "_shasum": "28af32b452b9fd28975133809cfd411fc8b21879",
  "_resolved": "https://registry.npmjs.org/asset-pipeline/-/asset-pipeline-0.3.2.tgz"
}
